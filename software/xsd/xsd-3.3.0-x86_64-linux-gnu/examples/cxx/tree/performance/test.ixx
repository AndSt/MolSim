// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef TEST_IXX
#define TEST_IXX

// Begin prologue.
//
//
// End prologue.

namespace test
{
  // enum_
  // 

  inline
  enum_::
  enum_ (value v)
  : ::xml_schema::string (_xsd_enum__literals_[v])
  {
  }

  inline
  enum_::
  enum_ (const char* v)
  : ::xml_schema::string (v)
  {
  }

  inline
  enum_::
  enum_ (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  inline
  enum_::
  enum_ (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  inline
  enum_::
  enum_ (const enum_& v,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  inline
  enum_& enum_::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_enum__literals_[v]);

    return *this;
  }


  // record
  // 

  inline
  const record::int_type& record::
  int_ () const
  {
    return this->int__.get ();
  }

  inline
  record::int_type& record::
  int_ ()
  {
    return this->int__.get ();
  }

  inline
  void record::
  int_ (const int_type& x)
  {
    this->int__.set (x);
  }

  inline
  const record::double_type& record::
  double_ () const
  {
    return this->double__.get ();
  }

  inline
  record::double_type& record::
  double_ ()
  {
    return this->double__.get ();
  }

  inline
  void record::
  double_ (const double_type& x)
  {
    this->double__.set (x);
  }

  inline
  const record::name_type& record::
  name () const
  {
    return this->name_.get ();
  }

  inline
  record::name_type& record::
  name ()
  {
    return this->name_.get ();
  }

  inline
  void record::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  inline
  void record::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  inline
  const record::string_optional& record::
  string () const
  {
    return this->string_;
  }

  inline
  record::string_optional& record::
  string ()
  {
    return this->string_;
  }

  inline
  void record::
  string (const string_type& x)
  {
    this->string_.set (x);
  }

  inline
  void record::
  string (const string_optional& x)
  {
    this->string_ = x;
  }

  inline
  void record::
  string (::std::auto_ptr< string_type > x)
  {
    this->string_.set (x);
  }

  inline
  const record::choice1_optional& record::
  choice1 () const
  {
    return this->choice1_;
  }

  inline
  record::choice1_optional& record::
  choice1 ()
  {
    return this->choice1_;
  }

  inline
  void record::
  choice1 (const choice1_type& x)
  {
    this->choice1_.set (x);
  }

  inline
  void record::
  choice1 (const choice1_optional& x)
  {
    this->choice1_ = x;
  }

  inline
  void record::
  choice1 (::std::auto_ptr< choice1_type > x)
  {
    this->choice1_.set (x);
  }

  inline
  const record::choice2_optional& record::
  choice2 () const
  {
    return this->choice2_;
  }

  inline
  record::choice2_optional& record::
  choice2 ()
  {
    return this->choice2_;
  }

  inline
  void record::
  choice2 (const choice2_type& x)
  {
    this->choice2_.set (x);
  }

  inline
  void record::
  choice2 (const choice2_optional& x)
  {
    this->choice2_ = x;
  }

  inline
  void record::
  choice2 (::std::auto_ptr< choice2_type > x)
  {
    this->choice2_.set (x);
  }

  inline
  const record::choice3_optional& record::
  choice3 () const
  {
    return this->choice3_;
  }

  inline
  record::choice3_optional& record::
  choice3 ()
  {
    return this->choice3_;
  }

  inline
  void record::
  choice3 (const choice3_type& x)
  {
    this->choice3_.set (x);
  }

  inline
  void record::
  choice3 (const choice3_optional& x)
  {
    this->choice3_ = x;
  }

  inline
  void record::
  choice3 (::std::auto_ptr< choice3_type > x)
  {
    this->choice3_.set (x);
  }

  inline
  const record::choice4_optional& record::
  choice4 () const
  {
    return this->choice4_;
  }

  inline
  record::choice4_optional& record::
  choice4 ()
  {
    return this->choice4_;
  }

  inline
  void record::
  choice4 (const choice4_type& x)
  {
    this->choice4_.set (x);
  }

  inline
  void record::
  choice4 (const choice4_optional& x)
  {
    this->choice4_ = x;
  }

  inline
  void record::
  choice4 (::std::auto_ptr< choice4_type > x)
  {
    this->choice4_.set (x);
  }

  inline
  const record::enum_type& record::
  enum_ () const
  {
    return this->enum__.get ();
  }

  inline
  record::enum_type& record::
  enum_ ()
  {
    return this->enum__.get ();
  }

  inline
  void record::
  enum_ (const enum_type& x)
  {
    this->enum__.set (x);
  }

  inline
  void record::
  enum_ (::std::auto_ptr< enum_type > x)
  {
    this->enum__.set (x);
  }

  inline
  const record::apple_optional& record::
  apple () const
  {
    return this->apple_;
  }

  inline
  record::apple_optional& record::
  apple ()
  {
    return this->apple_;
  }

  inline
  void record::
  apple (const apple_type& x)
  {
    this->apple_.set (x);
  }

  inline
  void record::
  apple (const apple_optional& x)
  {
    this->apple_ = x;
  }

  inline
  const record::orange_type& record::
  orange () const
  {
    return this->orange_.get ();
  }

  inline
  record::orange_type& record::
  orange ()
  {
    return this->orange_.get ();
  }

  inline
  void record::
  orange (const orange_type& x)
  {
    this->orange_.set (x);
  }


  // root
  // 

  inline
  const root::record_sequence& root::
  record () const
  {
    return this->record_;
  }

  inline
  root::record_sequence& root::
  record ()
  {
    return this->record_;
  }

  inline
  void root::
  record (const record_sequence& s)
  {
    this->record_ = s;
  }
}

// Begin epilogue.
//
//
// End epilogue.

#endif // TEST_IXX
