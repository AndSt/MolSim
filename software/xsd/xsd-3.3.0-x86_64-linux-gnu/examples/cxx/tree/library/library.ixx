// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef LIBRARY_IXX
#define LIBRARY_IXX

// Begin prologue.
//
//
// End prologue.

namespace library
{
  // isbn
  // 


  // title
  // 

  inline
  const title::lang_optional& title::
  lang () const
  {
    return this->lang_;
  }

  inline
  title::lang_optional& title::
  lang ()
  {
    return this->lang_;
  }

  inline
  void title::
  lang (const lang_type& x)
  {
    this->lang_.set (x);
  }

  inline
  void title::
  lang (const lang_optional& x)
  {
    this->lang_ = x;
  }

  inline
  void title::
  lang (::std::auto_ptr< lang_type > x)
  {
    this->lang_.set (x);
  }


  // genre
  // 

  inline
  genre::
  genre (value v)
  : ::xml_schema::string (_xsd_genre_literals_[v])
  {
  }

  inline
  genre::
  genre (const char* v)
  : ::xml_schema::string (v)
  {
  }

  inline
  genre::
  genre (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  inline
  genre::
  genre (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  inline
  genre::
  genre (const genre& v,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  inline
  genre& genre::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_genre_literals_[v]);

    return *this;
  }


  // person
  // 

  inline
  const person::name_type& person::
  name () const
  {
    return this->name_.get ();
  }

  inline
  person::name_type& person::
  name ()
  {
    return this->name_.get ();
  }

  inline
  void person::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  inline
  void person::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  inline
  const person::born_type& person::
  born () const
  {
    return this->born_.get ();
  }

  inline
  person::born_type& person::
  born ()
  {
    return this->born_.get ();
  }

  inline
  void person::
  born (const born_type& x)
  {
    this->born_.set (x);
  }

  inline
  void person::
  born (::std::auto_ptr< born_type > x)
  {
    this->born_.set (x);
  }

  inline
  const person::died_optional& person::
  died () const
  {
    return this->died_;
  }

  inline
  person::died_optional& person::
  died ()
  {
    return this->died_;
  }

  inline
  void person::
  died (const died_type& x)
  {
    this->died_.set (x);
  }

  inline
  void person::
  died (const died_optional& x)
  {
    this->died_ = x;
  }

  inline
  void person::
  died (::std::auto_ptr< died_type > x)
  {
    this->died_.set (x);
  }


  // author
  // 

  inline
  const author::recommends_optional& author::
  recommends () const
  {
    return this->recommends_;
  }

  inline
  author::recommends_optional& author::
  recommends ()
  {
    return this->recommends_;
  }

  inline
  void author::
  recommends (const recommends_type& x)
  {
    this->recommends_.set (x);
  }

  inline
  void author::
  recommends (const recommends_optional& x)
  {
    this->recommends_ = x;
  }

  inline
  void author::
  recommends (::std::auto_ptr< recommends_type > x)
  {
    this->recommends_.set (x);
  }


  // book
  // 

  inline
  const book::isbn_type& book::
  isbn () const
  {
    return this->isbn_.get ();
  }

  inline
  book::isbn_type& book::
  isbn ()
  {
    return this->isbn_.get ();
  }

  inline
  void book::
  isbn (const isbn_type& x)
  {
    this->isbn_.set (x);
  }

  inline
  void book::
  isbn (::std::auto_ptr< isbn_type > x)
  {
    this->isbn_.set (x);
  }

  inline
  const book::title_type& book::
  title () const
  {
    return this->title_.get ();
  }

  inline
  book::title_type& book::
  title ()
  {
    return this->title_.get ();
  }

  inline
  void book::
  title (const title_type& x)
  {
    this->title_.set (x);
  }

  inline
  void book::
  title (::std::auto_ptr< title_type > x)
  {
    this->title_.set (x);
  }

  inline
  const book::genre_type& book::
  genre () const
  {
    return this->genre_.get ();
  }

  inline
  book::genre_type& book::
  genre ()
  {
    return this->genre_.get ();
  }

  inline
  void book::
  genre (const genre_type& x)
  {
    this->genre_.set (x);
  }

  inline
  void book::
  genre (::std::auto_ptr< genre_type > x)
  {
    this->genre_.set (x);
  }

  inline
  const book::author_sequence& book::
  author () const
  {
    return this->author_;
  }

  inline
  book::author_sequence& book::
  author ()
  {
    return this->author_;
  }

  inline
  void book::
  author (const author_sequence& s)
  {
    this->author_ = s;
  }

  inline
  const book::available_type& book::
  available () const
  {
    return this->available_.get ();
  }

  inline
  book::available_type& book::
  available ()
  {
    return this->available_.get ();
  }

  inline
  void book::
  available (const available_type& x)
  {
    this->available_.set (x);
  }

  inline
  book::available_type book::
  available_default_value ()
  {
    return available_type (true);
  }

  inline
  const book::id_type& book::
  id () const
  {
    return this->id_.get ();
  }

  inline
  book::id_type& book::
  id ()
  {
    return this->id_.get ();
  }

  inline
  void book::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  inline
  void book::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }


  // catalog
  // 

  inline
  const catalog::book_sequence& catalog::
  book () const
  {
    return this->book_;
  }

  inline
  catalog::book_sequence& catalog::
  book ()
  {
    return this->book_;
  }

  inline
  void catalog::
  book (const book_sequence& s)
  {
    this->book_ = s;
  }
}

// Begin epilogue.
//
//
// End epilogue.

#endif // LIBRARY_IXX
